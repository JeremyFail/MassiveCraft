package com.massivecraft.factions.engine;

import com.massivecraft.factions.Factions;
import com.massivecraft.factions.entity.MConf;
import com.massivecraft.factions.util.EnumerationUtil;
import com.massivecraft.massivecore.Engine;
import com.massivecraft.massivecore.collections.MassiveList;
import com.massivecraft.massivecore.mixin.MixinMessage;
import com.massivecraft.massivecore.ps.PS;
import com.massivecraft.massivecore.util.MUtil;
import com.massivecraft.massivecore.util.Txt;

import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.WorldBorder;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.data.Directional;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class EngineExploit extends Engine
{
	// -------------------------------------------- //
	// INSTANCE & CONSTRUCT
	// -------------------------------------------- //
	
	private static EngineExploit i = new EngineExploit();
	public static EngineExploit get() { return i; }
	
	// -------------------------------------------- //
	// OBSIDIAN GENERATORS
	// -------------------------------------------- //

	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void obsidianGenerators(BlockFromToEvent event)
	{
		if (!MConf.get().handleExploitObsidianGenerators) return;

		// thanks to ObGenBlocker and WorldGuard for this method
		Block block = event.getToBlock();
		Material source = event.getBlock().getType();
		Material target = block.getType();
		if ((target == Material.REDSTONE_WIRE || target == Material.TRIPWIRE) && (source == Material.AIR || source == Material.LAVA))
		{
			block.setType(Material.AIR);
		}
	}

	// -------------------------------------------- //
	// ENDER PEARL EXPLOITS
	// -------------------------------------------- //

	// Map to track players who recently attempted to break blocks
	private final Map<UUID, Long> playerBlockBreakCooldown = new ConcurrentHashMap<>();

	@EventHandler(priority = EventPriority.MONITOR)
	public void trackBlockBreak(BlockBreakEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlBlockBreak) return;
		
		Player player = event.getPlayer();
		UUID playerId = player.getUniqueId();
		long currentTime = System.currentTimeMillis();
		
		// Track the player regardless of whether the break was cancelled
		playerBlockBreakCooldown.put(playerId, currentTime);
		
		// Schedule removal after cooldown - convert milliseconds to ticks (1 tick = 50 ms) + 40 ticks buffer (2 seconds)
		long removalDelay = (MConf.get().enderPearlBlockBreakCooldownMillis / 50) + 40;
		long scheduledTime = currentTime;
		Bukkit.getScheduler().runTaskLater(this.getPlugin(), () -> {
			// Only remove if the timestamp matches, ensuring we don't remove a more recent break
			// This prevents a race condition where multiple breaks happen in quick succession
			Long lastBreakTime = playerBlockBreakCooldown.get(playerId);
			if (lastBreakTime != null && lastBreakTime == scheduledTime) {
				playerBlockBreakCooldown.remove(playerId);
			}
		}, removalDelay);
	}

	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void enderPearlBlockBreakExploit(PlayerTeleportEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlBlockBreak) return;
		if (event.getCause() != TeleportCause.ENDER_PEARL) return;
		
		Player player = event.getPlayer();
		UUID playerId = player.getUniqueId();
		Long lastBreakTime = playerBlockBreakCooldown.get(playerId);
		
		if (lastBreakTime != null)
		{
			long timeSinceBreak = System.currentTimeMillis() - lastBreakTime;
			if (timeSinceBreak < MConf.get().enderPearlBlockBreakCooldownMillis)
			{
				event.setTo(event.getFrom());
				MixinMessage.get().messageOne(player, Txt.parse("<b>You cannot use ender pearls for " + 
					String.format("%.1f", (MConf.get().enderPearlBlockBreakCooldownMillis - timeSinceBreak) / 1000.0) + 
					" more seconds."));
				
				// Return the ender pearl to the player (as it will have been consumed)
				// Check that player is not in creative mode
				if (player.getGameMode() != GameMode.CREATIVE)
				{
					// First check Main hand
					ItemStack mainHand = player.getInventory().getItemInMainHand();
					if (mainHand.getType() == Material.ENDER_PEARL && mainHand.getAmount() < mainHand.getMaxStackSize())
					{
						mainHand.setAmount(mainHand.getAmount() + 1);
						player.getInventory().setItemInMainHand(mainHand);
						return;
					}

					// Otherwise check Offhand
					ItemStack offHand = player.getInventory().getItemInOffHand();
					if (offHand.getType() == Material.ENDER_PEARL && offHand.getAmount() < offHand.getMaxStackSize())
					{
						offHand.setAmount(offHand.getAmount() + 1);
						player.getInventory().setItemInOffHand(offHand);
						return;
					}

					// Otherwise check inventory for stack with room
					for (int i = 0; i < player.getInventory().getSize(); i++) {
						ItemStack stack = player.getInventory().getItem(i);
						if (stack != null && stack.getType() == Material.ENDER_PEARL && stack.getAmount() < stack.getMaxStackSize())
						{
							stack.setAmount(stack.getAmount() + 1);
							player.getInventory().setItem(i, stack);
							return;
						}
					}

					// Otherwise just add to inventory (will drop if full)
					ItemStack pearl = new ItemStack(Material.ENDER_PEARL, 1);
					Map<Integer, ItemStack> leftovers = player.getInventory().addItem(pearl);
					if (!leftovers.isEmpty())
					{
						player.getWorld().dropItemNaturally(player.getLocation(), pearl);
					}
					player.getInventory().addItem(new ItemStack(Material.ENDER_PEARL, 1));
				}
			}
		}
	}
	
	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void enderPearlWorldBorder(PlayerTeleportEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlWorldBorder) return;
		if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) return;
		
		Location target = event.getTo();
		assert target != null;
		
		World world = target.getWorld();
		assert world != null;
		
		WorldBorder worldBorder = world.getWorldBorder();
		
		if (!worldBorder.isInside(target)) event.setCancelled(true);
	}
	
	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void enderPearlClipping(PlayerTeleportEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlClipping) return;
		if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) return;

		// There are multiple ways players can attempt to clip through blocks using ender pearls.
		// The checks below handle several common methods.
		Location target = event.getTo();
		Location from = event.getFrom();
		Location blockLocation = target.getBlock().getLocation();

		// Blocks that occupy less than 1 block width or length need to be handled differently
		Material mat = target.getBlock().getType();

		// Check if the player might be attempting to clip through the bottom of a block - primarily
		// done when standing next to a door/trapdoor/fence gate, but could apply to other blocks as well.
		if (clippingThroughBottomOfBlock(target, from))
		{
			event.setTo(from);
			event.setCancelled(true);
			return;
		}

		// Check if the player is attempting to clip through the bottom of a block diagonally,
		// specifically when standing diagonally next to a door/trapdoor/fence gate.
		if (possibleDiagonalClipThroughBottomOfBlock(target, from))
		{
			// Get nearby blocks on all four sides of target block (N, E, S, W), as well as the
			// "from" block, to check for doors. In this case we only care about 
			// doors/trapdoors/fence gates since they are easiest to clip through using this method
			Location fromBlockLocation = from.getBlock().getLocation();

			List<Block> nearbyBlocks = new MassiveList<>();
			nearbyBlocks.add(blockLocation.clone().add(1, 0, 0).getBlock());     // Target East
			nearbyBlocks.add(blockLocation.clone().add(-1, 0, 0).getBlock());      // Target West
			nearbyBlocks.add(blockLocation.clone().add(0, 0, 1).getBlock());     // Target South
			nearbyBlocks.add(blockLocation.clone().add(0, 0, -1).getBlock());      // Target North
			nearbyBlocks.add(fromBlockLocation.clone().add(1, 0, 0).getBlock()); // From East
			nearbyBlocks.add(fromBlockLocation.clone().add(-1, 0, 0).getBlock());  // From West
			nearbyBlocks.add(fromBlockLocation.clone().add(0, 0, 1).getBlock()); // From South
			nearbyBlocks.add(fromBlockLocation.clone().add(0, 0, -1).getBlock());  // From North
			for (Block nearbyBlock : nearbyBlocks)
			{
				Material nearbyMat = nearbyBlock.getType();
				if (EnumerationUtil.isMaterialDoorOrRelated(nearbyMat))
				{
					// Found a door, assume they are attempting to clip through it
					event.setTo(from);
					event.setCancelled(true);
					return;
				}
			}
		}

		// Doors/trapdoors/fence gates - due to their unique shape and interaction,
		// we will manually handle teleporting to their center and prevent clipping through
		if (EnumerationUtil.isMaterialDoorOrRelated(mat))
		{
			// Get the facing direction of the door/trapdoor/fence gate to determine which side
			// the player is trying to teleport through and adjust accordingly
			Directional directionalData = (Directional) target.getBlock().getBlockData();
			BlockFace facing = directionalData.getFacing();
			
			// Calculate which side of the door the player should be teleported to
			// based on their original position relative to the door's facing direction
			double doorCenterX = blockLocation.getX() + 0.5;
			double doorCenterZ = blockLocation.getZ() + 0.5;
			
			// Determine which block to teleport to based on door facing and player's original position
			int targetBlockOffsetX = 0;
			int targetBlockOffsetZ = 0;
			
			// Calculate which side of the door the player was on
			// Vector from door center to player's original position
			double playerRelativeX = from.getX() - doorCenterX;
			double playerRelativeZ = from.getZ() - doorCenterZ;
			
			// Door's facing direction vector
			double facingX = facing.getModX();
			double facingZ = facing.getModZ();
			
			// Calculate which side of the door the player is on relative to the door's facing direction
			double playerSideRelativeToFacing = (playerRelativeX * facingX) + (playerRelativeZ * facingZ);
			
			// Player is on the "inside" of the door (the direction it faces), place them on the block the door is on
			if (playerSideRelativeToFacing >= 0) {
				
				targetBlockOffsetX = 0;
				targetBlockOffsetZ = 0;
			} 
			// Player is on the "outside" (the side away from the door), place them on the block behind the door
			else 
			{
				if (facing == BlockFace.NORTH || facing == BlockFace.SOUTH)
				{
					targetBlockOffsetX = 0;
					targetBlockOffsetZ = (int) -facingZ;
				}
				else
				{
					targetBlockOffsetX = (int) -facingX;
					targetBlockOffsetZ = 0;
				}
			}

			// Calculate the target block location
			Location targetBlock = blockLocation.clone().add(targetBlockOffsetX, 0, targetBlockOffsetZ);
			
			// Determine the manual teleport location at the exact center of the target block
			Location teleportLocation = new Location(
				event.getPlayer().getWorld(),
				targetBlock.getX() + 0.5,  // Always exactly centered in X
				blockLocation.getY(),
				targetBlock.getZ() + 0.5,  // Always exactly centered in Z
				target.getYaw(),
				target.getPitch()
			);

			// If they aren't directly clipping through, check if they are within 3 blocks vertically
			// as they may be trying to clip through the top of a door, which we should prevent
			if (target.getBlockX() == blockLocation.getBlockX() && target.getBlockZ() == blockLocation.getBlockZ()
				&& Math.abs(target.getBlockY() - blockLocation.getBlockY()) <= 3)
			{
				// Check if block above block Y is not air (indicating they are trying to clip through the top).
				// Also check that it is not the same material (door/trapdoor/fence gate) or another type of 
				// door/trapdoor/fence gate to avoid false positives.
				Block aboveTarget = blockLocation.clone().add(0, 1, 0).getBlock();
				if (aboveTarget.getType() != Material.AIR && aboveTarget.getType() != mat && !EnumerationUtil.isMaterialDoorOrRelated(aboveTarget.getType()))
				{
					// Shift the target down one block to prevent clipping through the top
					teleportLocation.setY(blockLocation.getY() - 1);
				}
			}

			// Teleport them to the block we determined is where they should go
			// Defer the teleport by one tick due to teleporting inside a teleport event being ignored
			event.setTo(from);
			event.setCancelled(true);
			Bukkit.getScheduler().runTask(Factions.get(), () -> {
				event.getPlayer().teleport(teleportLocation, TeleportCause.PLUGIN);
			});
			return;
		}
		
		// Check if the target location is within a certain width in comparison to a narrow block 
		// (e.g. fences, walls, panes, etc.) which causes the player to clip through the block
		if ((EnumerationUtil.isMaterialNarrowBlockPane(mat) && clippingThrough(target, from, 0.65))
			|| (EnumerationUtil.isMaterialNarrowBlockFence(mat) && clippingThrough(target, from, 0.45)))
		{			
			event.setTo(from);
			event.setCancelled(true);
			return;
		}

		// Simple fix otherwise: ender pearl target locations are standardized to be in the center (X/Z) of the target block, not at the edges
		target.setX(target.getBlockX() + 0.5);
		target.setZ(target.getBlockZ() + 0.5);
		event.setTo(target);
	}

	/**
	 * Checks if the target location is within a certain thickness of the from location.
	 * This is used to determine if a player is attempting to clip through a narrow block
	 * (block that does not take up the full width of a standard block).
	 * 
	 * @param target The target location to check.
	 * @param from The original location of the player.
	 * @param thickness The thickness to check for clipping.
	 * @return True if the player is clipping through the block, false otherwise.
	 */
	private static boolean clippingThrough(Location target, Location from, double thickness)
	{
		return
		(
			(from.getX() > target.getX() && (from.getX() - target.getX() < thickness))
		 || (target.getX() > from.getX() && (target.getX() - from.getX() < thickness))
		 || (from.getZ() > target.getZ() && (from.getZ() - target.getZ() < thickness))
		 || (target.getZ() > from.getZ() && (target.getZ() - from.getZ() < thickness))
		);
	}

	/**
	 * Checks if the player is attempting to clip through the bottom of a block. This
	 * is determined by checking if the block X and Z coordinates are the same for both
	 * the target and from locations, which indicates the player threw the pearl at the
	 * block they are currently standing on.
	 * 
	 * @param target The target location to check.
	 * @param from The original location of the player.
	 * @return True if the player is attempting to clip through a block, false otherwise.
	 */
	private static boolean clippingThroughBottomOfBlock(Location target, Location from)
	{
		return (from.getBlockX() == target.getBlockX() 
				&& from.getBlockZ() == target.getBlockZ());
	}
	
	/**
	 * Similar to clippingThroughBottomOfBlock, but checks if the target block is within 1
	 * block of the from block in the X and Z axes. This is to catch cases where the player is
	 * standing diagonally next to an easily clippable block (like a door or trapdoor) and throws
	 * the pearl at the neighboring block, attempting to clip through it.
	 * 
	 * Further checking should be done if this is detected to confirm the player is actually
	 * attempting to clip through the block (such as checking the specific block type or 
	 * neighboring block types).
	 * 
	 * @param target The target location to check.
	 * @param from The original location of the player.
	 * @return True if the player might be attempting to clip through a block, false otherwise.
	 */
	private static boolean possibleDiagonalClipThroughBottomOfBlock(Location target, Location from)
	{
		return (Math.abs(from.getBlockX() - target.getBlockX()) <= 1
				&& Math.abs(from.getBlockZ() - target.getBlockZ()) <= 1);
	}

	// -------------------------------------------- //
	// NETHER PORTAL TRAP 
	// -------------------------------------------- //
	// A nether portal trap can be created by the destination portal being enclosed (trapped) - resulting in the player not being able to run commands.
	// This fix removes the portal blocks (client side) from the destination until they are away from the portal.
	
	private static final int NETHER_TRAP_RADIUS_CHECK = 5;
	private static final int NETHER_TRAP_RESET_RADIUS_SQUARED = 9;
	
	private HashMap<UUID, List<Block>> portalTraps = new HashMap<>();
	
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void portalTrapRemoveAnimation(PlayerTeleportEvent event)
	{
		// If there is a teleport caused by a nether portal ...
		if ( ! MConf.get().handleNetherPortalTrap || event.getCause() != TeleportCause.NETHER_PORTAL) return;

		Player player = event.getPlayer();
		Block from = event.getTo().getBlock();

		// ... and the player can't build at the destination ...
		if (EnginePermBuild.canPlayerBuildAt(player, PS.valueOf(from), false)) return;
				
		// ... reset the old portal blocks stored ...
		this.portalReset(player);
		
		// ... get all the portal blocks belonging to the new portal at the destination ...
		List<Block> portalTrap = getPortal(from);
		if (portalTrap.isEmpty()) return;

		// ... and then store those blocks and send an update as if they were air.
		this.portalTraps.put(player.getUniqueId(), portalTrap);
		portalUpdateAir(player, portalTrap);
	}
	
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void portalUpdate(PlayerMoveEvent event)
	{
		// If a player moves ...
		if (!MConf.get().handleNetherPortalTrap || MUtil.isSameBlock(event)) return;
		
		Player player = event.getPlayer();
		UUID uuid = player.getUniqueId();
		
		// ... and he recently used a portal ...
		List<Block> portalTrap = this.portalTraps.get(uuid);
		if (portalTrap == null) return;

		Location locationTo = event.getTo();
		Location locationFrom = portalTrap.get(0).getLocation();

		World worldTo = locationTo.getWorld();
		World worldFrom = locationFrom.getWorld();

		// ... update reset the portal near them, if they have moved away too far ...
		if (!worldTo.equals(worldFrom) || locationTo.distanceSquared(locationFrom) > NETHER_TRAP_RESET_RADIUS_SQUARED)
		{
			portalUpdateReset(player, portalTrap);
			return;
		}

		// ... or send an update as if the portal blocks were air.
		portalUpdateAir(player, portalTrap);
	}
	
	public void portalReset(Player player)
	{
		UUID uuid = player.getUniqueId();

		// If a player has already a portal registered to him ...
		List<Block> portalTrap = this.portalTraps.get(uuid);
		if (portalTrap == null) return;

		// ... remove them from the registry ...
		this.portalTraps.remove(uuid);
		
		// ... and send updates if the player and portal are in the same world.
		if ( ! player.getWorld().equals(portalTrap.get(0).getWorld())) return;
		portalUpdateReset(player, portalTrap);
	}

	public static void portalUpdateReset(Player player, List<Block> portal) { portalUpdate(player, portal, null, null); }
	public static void portalUpdateAir(Player player, List<Block> portal) { portalUpdate(player, portal, Material.AIR, (byte) 0); }

	@SuppressWarnings("deprecation")
	private static void portalUpdate(Player player, List<Block> portal, Material material, Byte data)
	{
		boolean usingDefault = material == null && data == null;
		for (Block block : portal)
		{
			Material updateMaterial = usingDefault ? block.getType() : material;
			byte updateData = usingDefault ? block.getData() : data;
			player.sendBlockChange(block.getLocation(), updateMaterial, updateData);
		}
	}

	public static List<Block> getPortal(Block from)
	{
		// Create
		List<Block> ret = new MassiveList<>();
		
		// Fill - Check in a radius of the block to find the portal blocks
		for (int x = -(NETHER_TRAP_RADIUS_CHECK); x <= NETHER_TRAP_RADIUS_CHECK; x ++)
		{
			for (int y = -(NETHER_TRAP_RADIUS_CHECK); y <= NETHER_TRAP_RADIUS_CHECK; y ++)
			{
				for (int z = -(NETHER_TRAP_RADIUS_CHECK); z <= NETHER_TRAP_RADIUS_CHECK; z ++)
				{
					if (from.getRelative(x, y, z).getType() == Material.NETHER_PORTAL) ret.add(from.getRelative(x, y, z));
				}
			}
		}

		// Return
		return ret;
	}
}
