package com.massivecraft.factions.engine;

import com.massivecraft.factions.Factions;
import com.massivecraft.factions.entity.MConf;
import com.massivecraft.factions.util.EnumerationUtil;
import com.massivecraft.massivecore.Engine;
import com.massivecraft.massivecore.collections.MassiveList;
import com.massivecraft.massivecore.mixin.MixinMessage;
import com.massivecraft.massivecore.ps.PS;
import com.massivecraft.massivecore.util.MUtil;
import com.massivecraft.massivecore.util.Txt;

import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.WorldBorder;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class EngineExploit extends Engine
{
	// -------------------------------------------- //
	// INSTANCE & CONSTRUCT
	// -------------------------------------------- //
	
	private static EngineExploit i = new EngineExploit();
	public static EngineExploit get() { return i; }
	
	// -------------------------------------------- //
	// OBSIDIAN GENERATORS
	// -------------------------------------------- //

	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void obsidianGenerators(BlockFromToEvent event)
	{
		if (!MConf.get().handleExploitObsidianGenerators) return;

		// thanks to ObGenBlocker and WorldGuard for this method
		Block block = event.getToBlock();
		Material source = event.getBlock().getType();
		Material target = block.getType();
		if ((target == Material.REDSTONE_WIRE || target == Material.TRIPWIRE) && (source == Material.AIR || source == Material.LAVA))
		{
			block.setType(Material.AIR);
		}
	}

	// -------------------------------------------- //
	// ENDER PEARL EXPLOITS
	// -------------------------------------------- //

	// Map to track players who recently attempted to break blocks
	private final Map<UUID, Long> playerBlockBreakCooldown = new ConcurrentHashMap<>();

	@EventHandler(priority = EventPriority.MONITOR)
	public void trackBlockBreak(BlockBreakEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlBlockBreak) return;
		
		Player player = event.getPlayer();
		UUID playerId = player.getUniqueId();
		long currentTime = System.currentTimeMillis();
		
		// Track the player regardless of whether the break was cancelled
		playerBlockBreakCooldown.put(playerId, currentTime);
		
		// Schedule removal after cooldown - convert milliseconds to ticks (1 tick = 50 ms) + 40 ticks buffer (2 seconds)
		long removalDelay = (MConf.get().enderPearlBlockBreakCooldownMillis / 50) + 40;
		long scheduledTime = currentTime;
		Bukkit.getScheduler().runTaskLater(this.getPlugin(), () -> {
			// Only remove if the timestamp matches, ensuring we don't remove a more recent break
			// This prevents a race condition where multiple breaks happen in quick succession
			Long lastBreakTime = playerBlockBreakCooldown.get(playerId);
			if (lastBreakTime != null && lastBreakTime == scheduledTime) {
				playerBlockBreakCooldown.remove(playerId);
			}
		}, removalDelay);
	}

	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void enderPearlBlockBreakExploit(PlayerTeleportEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlBlockBreak) return;
		if (event.getCause() != TeleportCause.ENDER_PEARL) return;
		
		Player player = event.getPlayer();
		UUID playerId = player.getUniqueId();
		Long lastBreakTime = playerBlockBreakCooldown.get(playerId);
		
		if (lastBreakTime != null)
		{
			long timeSinceBreak = System.currentTimeMillis() - lastBreakTime;
			if (timeSinceBreak < MConf.get().enderPearlBlockBreakCooldownMillis)
			{
				event.setTo(event.getFrom());
				MixinMessage.get().messageOne(player, Txt.parse("<b>You cannot use ender pearls for " + 
					String.format("%.1f", (MConf.get().enderPearlBlockBreakCooldownMillis - timeSinceBreak) / 1000.0) + 
					" more seconds."));
				
				// Return the ender pearl to the player (as it will have been consumed)
				// Check that player is not in creative mode
				if (player.getGameMode() != GameMode.CREATIVE)
				{
					// First check Main hand
					ItemStack mainHand = player.getInventory().getItemInMainHand();
					if (mainHand.getType() == Material.ENDER_PEARL && mainHand.getAmount() < mainHand.getMaxStackSize())
					{
						mainHand.setAmount(mainHand.getAmount() + 1);
						player.getInventory().setItemInMainHand(mainHand);
						return;
					}

					// Otherwise check Offhand
					ItemStack offHand = player.getInventory().getItemInOffHand();
					if (offHand.getType() == Material.ENDER_PEARL && offHand.getAmount() < offHand.getMaxStackSize())
					{
						offHand.setAmount(offHand.getAmount() + 1);
						player.getInventory().setItemInOffHand(offHand);
						return;
					}

					// Otherwise check inventory for stack with room
					for (int i = 0; i < player.getInventory().getSize(); i++) {
						ItemStack stack = player.getInventory().getItem(i);
						if (stack != null && stack.getType() == Material.ENDER_PEARL && stack.getAmount() < stack.getMaxStackSize())
						{
							stack.setAmount(stack.getAmount() + 1);
							player.getInventory().setItem(i, stack);
							return;
						}
					}

					// Otherwise just add to inventory (will drop if full)
					ItemStack pearl = new ItemStack(Material.ENDER_PEARL, 1);
					Map<Integer, ItemStack> leftovers = player.getInventory().addItem(pearl);
					if (!leftovers.isEmpty())
					{
						player.getWorld().dropItemNaturally(player.getLocation(), pearl);
					}
					player.getInventory().addItem(new ItemStack(Material.ENDER_PEARL, 1));
				}
			}
		}
	}
	
	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void enderPearlWorldBorder(PlayerTeleportEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlWorldBorder) return;
		if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) return;
		
		Location target = event.getTo();
		assert target != null;
		
		World world = target.getWorld();
		assert world != null;
		
		WorldBorder worldBorder = world.getWorldBorder();
		
		if (!worldBorder.isInside(target)) event.setCancelled(true);
	}
	
	@EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
	public void enderPearlClipping(PlayerTeleportEvent event)
	{
		if (!MConf.get().handleExploitEnderPearlClipping) return;
		if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) return;

		// This exploit works when the target location is within a fraction of a block that
		// causes the player to clip through the block
		Location target = event.getTo();
		Location from = event.getFrom();
		Location blockLocation = target.getBlock().getLocation();

		// Blocks that occupy less than 1 block width or length need to be handled differently
		Material mat = target.getBlock().getType();

		// Doors/trapdoors/fence gates - due to their unique shape and interaction,
		// we will manually handle teleporting to their center and prevent clipping through
		if (EnumerationUtil.isMaterialDoorOrRelated(mat))
		{
			if (clippingThroughDoor(blockLocation, target, from))
			{
				event.setTo(from);
				return;
			}

			// Determine the manual teleport location at the center of the door block
			Location teleportLocation = new Location(
				event.getPlayer().getWorld(),
				blockLocation.getX() + 0.5,
				blockLocation.getY(),
				blockLocation.getZ() + 0.5,
				target.getYaw(),
				target.getPitch()
			);

			// If they aren't directly clipping through, check if they are within 3 blocks vertically
			// as they may be trying to clip through the top of a door, which we should prevent
			if (target.getBlockX() == blockLocation.getBlockX() && target.getBlockZ() == blockLocation.getBlockZ()
				&& Math.abs(target.getBlockY() - blockLocation.getBlockY()) <= 3)
			{
				// Check if block above block Y is not air (indicating they are trying to clip through the top).
				// Also check that it is not the same material (door/trapdoor/fence gate) or another type of 
				// door/trapdoor/fence gate to avoid false positives.
				Block aboveTarget = blockLocation.clone().add(0, 1, 0).getBlock();
				if (aboveTarget.getType() != Material.AIR && aboveTarget.getType() != mat && !EnumerationUtil.isMaterialDoorOrRelated(aboveTarget.getType()))
				{
					// Shift the target down one block to prevent clipping through the top
					teleportLocation.setY(blockLocation.getY() - 1);
				}
			}

			// Teleport them to the center of the door block
			// Defer the teleport by one tick due to teleporting inside a teleport event being ignored
			event.setTo(from);
			Bukkit.getScheduler().runTask(Factions.get(), () -> {
				// TODO: Should we set it to TeleportCause.ENDER_PEARL? Will that trigger another event check and is that an issue?
				// TODO: Also, Should we cancel the event? And if so, should we cancel it in the other spots as well?
				// TODO: We might want to do this to ensure any other plugins listening for ender pearl teleports still function correctly.
				event.getPlayer().teleport(teleportLocation, TeleportCause.PLUGIN);
			});
			return;
		}
		// Other narrow blocks (fences, walls, panes, etc.)
		else if ((EnumerationUtil.isMaterialNarrowBlockPane(mat) && clippingThrough(target, from, 0.65))
			|| (EnumerationUtil.isMaterialNarrowBlockFence(mat) && clippingThrough(target, from, 0.45)))
		{			
			event.setTo(from);
			return;
		}

		// Simple fix otherwise: ender pearl target locations are standardized to be in the center (X/Z) of the target block, not at the edges
		target.setX(target.getBlockX() + 0.5);
		target.setZ(target.getBlockZ() + 0.5);
		event.setTo(target);
	}

	/**
	 * Checks if the target location is within a certain thickness of the from location.
	 * This is used to determine if a player is clipping through a block or not.
	 * 
	 * @param target The target location to check.
	 * @param from The original location of the player.
	 * @param thickness The thickness to check for clipping.
	 * @return True if the player is clipping through the block, false otherwise.
	 */
	public static boolean clippingThrough(Location target, Location from, double thickness)
	{
		return
		(
			(from.getX() == target.getX() && from.getZ() == target.getZ())
		 || (from.getX() > target.getX() && (from.getX() - target.getX() < thickness))
		 || (target.getX() > from.getX() && (target.getX() - from.getX() < thickness))
		 || (from.getZ() > target.getZ() && (from.getZ() - target.getZ() < thickness))
		 || (target.getZ() > from.getZ() && (target.getZ() - from.getZ() < thickness))
		);
	}

	public static boolean clippingThroughDoor(Location blockLocation, Location target, Location from)
	{
		// Moving straight up or down - attempting to clip through door
		return (from.getX() == target.getX() && from.getZ() == target.getZ());
	}

	// -------------------------------------------- //
	// NETHER PORTAL TRAP 
	// -------------------------------------------- //
	// A nether portal trap can be created by the destination portal being enclosed (trapped) - resulting in the player not being able to run commands.
	// This fix removes the portal blocks (client side) from the destination until they are away from the portal.
	
	private static final int NETHER_TRAP_RADIUS_CHECK = 5;
	private static final int NETHER_TRAP_RESET_RADIUS_SQUARED = 9;
	
	private HashMap<UUID, List<Block>> portalTraps = new HashMap<>();
	
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void portalTrapRemoveAnimation(PlayerTeleportEvent event)
	{
		// If there is a teleport caused by a nether portal ...
		if ( ! MConf.get().handleNetherPortalTrap || event.getCause() != TeleportCause.NETHER_PORTAL) return;

		Player player = event.getPlayer();
		Block from = event.getTo().getBlock();

		// ... and the player can't build at the destination ...
		if (EnginePermBuild.canPlayerBuildAt(player, PS.valueOf(from), false)) return;
				
		// ... reset the old portal blocks stored ...
		this.portalReset(player);
		
		// ... get all the portal blocks belonging to the new portal at the destination ...
		List<Block> portalTrap = getPortal(from);
		if (portalTrap.isEmpty()) return;

		// ... and then store those blocks and send an update as if they were air.
		this.portalTraps.put(player.getUniqueId(), portalTrap);
		portalUpdateAir(player, portalTrap);
	}
	
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void portalUpdate(PlayerMoveEvent event)
	{
		// If a player moves ...
		if (!MConf.get().handleNetherPortalTrap || MUtil.isSameBlock(event)) return;
		
		Player player = event.getPlayer();
		UUID uuid = player.getUniqueId();
		
		// ... and he recently used a portal ...
		List<Block> portalTrap = this.portalTraps.get(uuid);
		if (portalTrap == null) return;

		Location locationTo = event.getTo();
		Location locationFrom = portalTrap.get(0).getLocation();

		World worldTo = locationTo.getWorld();
		World worldFrom = locationFrom.getWorld();

		// ... update reset the portal near them, if they have moved away too far ...
		if (!worldTo.equals(worldFrom) || locationTo.distanceSquared(locationFrom) > NETHER_TRAP_RESET_RADIUS_SQUARED)
		{
			portalUpdateReset(player, portalTrap);
			return;
		}

		// ... or send an update as if the portal blocks were air.
		portalUpdateAir(player, portalTrap);
	}
	
	public void portalReset(Player player)
	{
		UUID uuid = player.getUniqueId();

		// If a player has already a portal registered to him ...
		List<Block> portalTrap = this.portalTraps.get(uuid);
		if (portalTrap == null) return;

		// ... remove them from the registry ...
		this.portalTraps.remove(uuid);
		
		// ... and send updates if the player and portal are in the same world.
		if ( ! player.getWorld().equals(portalTrap.get(0).getWorld())) return;
		portalUpdateReset(player, portalTrap);
	}

	public static void portalUpdateReset(Player player, List<Block> portal) { portalUpdate(player, portal, null, null); }
	public static void portalUpdateAir(Player player, List<Block> portal) { portalUpdate(player, portal, Material.AIR, (byte) 0); }

	@SuppressWarnings("deprecation")
	private static void portalUpdate(Player player, List<Block> portal, Material material, Byte data)
	{
		boolean usingDefault = material == null && data == null;
		for (Block block : portal)
		{
			Material updateMaterial = usingDefault ? block.getType() : material;
			byte updateData = usingDefault ? block.getData() : data;
			player.sendBlockChange(block.getLocation(), updateMaterial, updateData);
		}
	}

	public static List<Block> getPortal(Block from)
	{
		// Create
		List<Block> ret = new MassiveList<>();
		
		// Fill - Check in a radius of the block to find the portal blocks
		for (int x = -(NETHER_TRAP_RADIUS_CHECK); x <= NETHER_TRAP_RADIUS_CHECK; x ++)
		{
			for (int y = -(NETHER_TRAP_RADIUS_CHECK); y <= NETHER_TRAP_RADIUS_CHECK; y ++)
			{
				for (int z = -(NETHER_TRAP_RADIUS_CHECK); z <= NETHER_TRAP_RADIUS_CHECK; z ++)
				{
					if (from.getRelative(x, y, z).getType() == Material.NETHER_PORTAL) ret.add(from.getRelative(x, y, z));
				}
			}
		}

		// Return
		return ret;
	}
}
